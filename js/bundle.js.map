{"version":3,"sources":["webpack:///webpack/bootstrap 100bf1b59af9d3c44d57","webpack:///./js/main.js","webpack:///./js/pac-view.js","webpack:///./js/orb_object.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;;;;;;ACbD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAwB,YAAY;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA,yBAAwB,YAAY;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,OAAO,EAAE,OAAO;AACrC,QAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA,aAAY;AACZ;;AAEA;;AAEA,sBAAqB,wBAAwB;AAC7C,wBAAuB,6BAA6B;AACpD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC,wBAAwB;AACzD;;AAEA;AACA;;AAEA;AACA;;AAEA,MAAK;AACL;AACA,kCAAiC,wBAAwB;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL,wBAAuB,SAAS;AAChC,0BAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA;AACA,0BAAyB,IAAI,EAAE,IAAI,0BAA0B,UAAU,IAAI;AAC3E;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAqB,SAAS;AAC9B,wBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,wBAAuB,IAAI,EAAE,IAAI,0BAA0B,UAAU,IAAI;AACzE;AACA;AACA;;AAEA,sBAAqB,SAAS;AAC9B,wBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAqB,SAAS;AAC9B,wBAAuB,SAAS;AAChC;AACA;AACA;AACA,oCAAmC,IAAI,GAAG,IAAI;;AAE9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uDAAsD;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,gBAAgB,cAAc,eAAe;;AAE9E;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAkD;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,oBAAoB;AACvC;AACA;;AAEA;AACA;;AAEA;;AAEA,sBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;;AAGA;;;;;;;;ACtdA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA","file":"./js/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 100bf1b59af9d3c44d57\n **/","const BoardView = require('./pac-view.js');\n\ndocument.addEventListener(\"DOMContentLoaded\",\nfunction() {\n  const canvas =\n  document.getElementsByTagName(\"canvas\")[0];\n  const ctx = canvas.getContext(\"2d\");\n  const stage = new Kinetic.Stage({\n    container: 'game-board',\n    width: 604,\n    height: 524,\n  });\n  const board = new BoardView(stage, ctx);\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/main.js\n ** module id = 0\n ** module chunks = 0\n **/","const OrbObject = require('./orb_object.js');\n\n// 356 356 35697 45752 1241\n\nclass BoardView {\n  constructor(stage, ctx) {\n    this.stage = stage;\n    this.ctx = ctx;\n    this.orbs = [[], [], [], [], []];\n    this.orbCanvases = {};\n\n    this.setupBoard();\n    window.orbs = this.orbCanvases;\n    // this.renderImages();\n\n    window.stage = this.stage;\n    window.orbMove = new Audio('orb_move.mp3');\n    window.movedOrbs = [];\n    window.clicked = false;\n\n    window.orbArray = this.orbs;\n    window.findMatches = this.findMatches;\n    window.matchOrbs = this.matchOrbs;\n    window.dropOrbs = this.dropOrbs;\n    window.checkMatch = this.checkMatch;\n    window.checkMatchVert = this.checkMatchVert;\n    window.randomOrb = this.randomOrb;\n\n    window.reLoad = this.reLoad;\n    window.sleep = this.sleep;\n\n    this.playMusic();\n  }\n\n  setupBoard () {\n    for (let colIdx = 0; colIdx < 5; colIdx++) {\n      this.addRow(colIdx);\n    }\n    this.renderBoard();\n  }\n\n  playMusic() {\n    const songs = ['./mp3/999.mp3', './mp3/crypt43.mp3', './mp3/cryptconga.mp3', './mp3/descent.mp3', './mp3/devils.mp3', './mp3/evilem.mp3', './mp3/evilev.mp3', './mp3/hallow.mp3', './mp3/hexagon.mp3', './mp3/shinra.mp3', './mp3/unepiccast.mp3'];\n\n    let songNumber = Math.round(Math.random() * songs.length - 1);\n    let song = new Audio(songs[songNumber]);\n    song.volume = 0.5;\n\n    song.addEventListener('ended', function() {\n      this.currentTime = 0;\n      this.play();\n      }, false);\n    song.play();\n  }\n\n  addRow (colIdx) {\n    for (let rowIdx = 0; rowIdx < 6; rowIdx++) {\n      let orbType = Math.round(Math.random() * 5);\n      let src;\n      let orbColor;\n\n      if (orbType === 0) {\n          orbType = \"orb-fire\";\n          src = \"./img/fire-pin.png\";\n          orbColor = \"#990000\";\n        } else if (orbType === 1) {\n          orbType = \"orb-water\";\n          src = \"./img/water-pin.png\";\n          orbColor = \"#112288\";\n        } else if (orbType === 2) {\n          orbType = \"orb-wood\";\n          src = \"./img/wood-pin.png\";\n          orbColor = \"#005544\";\n        } else if (orbType === 3) {\n          orbType = \"orb-light\";\n          src = \"./img/light-pin.png\";\n          orbColor = \"#776611\";\n        } else if (orbType === 4) {\n          orbType = \"orb-dark\";\n          src = \"./img/dark-pin.png\";\n          orbColor = \"#772299\";\n        } else {\n          orbType = \"orb-heart\";\n          src = \"./img/heart-pin.png\";\n          orbColor = \"#dd2277\";\n      }\n      let orbject = new Kinetic.Circle({\n        x: (rowIdx + 0.5) * 100, y: (colIdx + 0.5) * 100,\n        src: src, fill: orbColor, color: orbType,\n        orbId: `orb${colIdx}${rowIdx}`, matched: false, matchId: 0\n      });\n\n      this.orbs[colIdx].push(orbject);\n    }\n  }\n\n  doLoad (that, layer, img, orb, pos, color) {\n    let orbImage = new Kinetic.Image({\n      x: orb.attrs.x - 50, y: orb.attrs.y - 50,\n      width: 100, height: 100,\n      image: img, pos: pos,\n      color: color, orbId: orb.attrs.orbId,\n      draggable: false, opacity: 1\n    });\n    layer.add(orbImage);\n    layer.draw();\n\n    that.orbCanvases[orbImage.attrs.orbId] = orbImage;\n\n    layer.on(\"mouseup\", that.handleMouseUp);\n    layer.on(\"mouseout\", that.handleMouseOut);\n    layer.on(\"mousemove\", that.handleMouseMove);\n  }\n\n  randomOrb () {\n    let orbType = Math.round(Math.random() * 5);\n    let src;\n    let orbColor;\n\n    if (orbType === 0) {\n        orbType = \"orb-fire\";\n        src = \"./img/fire-pin.png\";\n        orbColor = \"#990000\";\n      } else if (orbType === 1) {\n        orbType = \"orb-water\";\n        src = \"./img/water-pin.png\";\n        orbColor = \"#112288\";\n      } else if (orbType === 2) {\n        orbType = \"orb-wood\";\n        src = \"./img/wood-pin.png\";\n        orbColor = \"#005544\";\n      } else if (orbType === 3) {\n        orbType = \"orb-light\";\n        src = \"./img/light-pin.png\";\n        orbColor = \"#776611\";\n      } else if (orbType === 4) {\n        orbType = \"orb-dark\";\n        src = \"./img/dark-pin.png\";\n        orbColor = \"#772299\";\n      } else {\n        orbType = \"orb-heart\";\n        src = \"./img/heart-pin.png\";\n        orbColor = \"#dd2277\";\n    }\n\n    return {orbType, src, orbColor};\n  }\n\n  renderBoard () {\n\n    for (let row = 0; row < this.orbs.length; row++) {\n      for (let orb = 0; orb < this.orbs[row].length; orb++) {\n        let layer = new Kinetic.Layer();\n\n        this.stage.add(layer);\n\n        let img = new Image();\n        img.onload = this.doLoad.bind(\n          null, this,\n          layer, img,\n          this.orbs[row][orb], [row, orb],\n          this.orbs[row][orb].attrs.color\n        );\n        img.src = this.orbs[row][orb].attrs.src;\n\n      }\n    }\n  }\n\n  handleMouseUp (e, redoing) {\n\n    window.clicked = !window.clicked;\n    if (window.clicked) {\n      window.currentOrb = e.target;\n      window.currentOrb.setOpacity(0.2);\n      window.currentOrb.setSize({width: 105, height: 105});\n      // debugger\n\n      window.newX = e.target.attrs.x;\n      window.newY = e.target.attrs.y;\n\n      e.target.parent.clear();\n      e.target.parent.draw();\n\n    } else {\n      window.currentOrb.setOpacity(1);\n      window.currentOrb.setSize({width: 100, height: 100});\n      window.currentOrb.parent.clear();\n      window.currentOrb.parent.draw();\n      window.currentOrb = undefined;\n    }\n\n    if (!window.clicked) {\n      window.findMatches();\n    } else {\n      for (let row = 0; row < 5; row++) {\n        for (let col = 0; col < 6; col++) {\n          let color = window.orbArray[row][col].attrs.color;\n          let sek;\n          if (color === 'orb-fire') {\n            sek = \"#ff0000\";\n          } else if (color === 'orb-water') {\n            sek = \"#00ffe0\";\n          } else if (color === 'orb-wood') {\n            sek = \"#aeff00\";\n          } else if (color === 'orb-light') {\n            sek = \"#ffe400\";\n          } else if (color === 'orb-dark') {\n            sek = \"#8a00ff\";\n          } else {\n            sek = \"#ff00fc\";\n          }\n          console.log(`${row}${col}%c(■)`, `background: #222; color: ${sek}`);\n        }\n        console.log(\"___\");\n      }\n    }\n  }\n\n  handleMouseOut (e) {\n  }\n\n  handleMouseMove (e) {\n    // console.log(e.target.attrs.orbId);\n\n    if (window.currentOrb !== undefined && (window.currentOrb.attrs.orbId !== e.target.attrs.orbId) && window.clicked) {\n\n      window.orbMove.currentTime = 0;\n      window.orbMove.play();\n\n      let targOrbX = e.target.attrs.x;\n      let targOrbY = e.target.attrs.y;\n      // This is the target orb that's being changed's value\n      // We're storing this in targOrb\n      e.target.x(window.newX);\n      e.target.y(window.newY);\n\n      // Here we have the previously set current orb's position becoming\n      // the target orb's position\n\n      window.newX = targOrbX;\n      window.newY = targOrbY;\n\n      let x1 = window.currentOrb.attrs.pos[0];\n      let y1 = window.currentOrb.attrs.pos[1];\n\n      let x2 = e.target.attrs.pos[0];\n      let y2 = e.target.attrs.pos[1];\n\n      let orb1 = window.orbArray[x1][y1];\n      let orb2 = window.orbArray[x2][y2];\n\n      [orb1.attrs.x, orb2.attrs.x] = [orb2.attrs.x, orb1.attrs.x];\n      [orb1.attrs.y, orb2.attrs.y] = [orb2.attrs.y, orb1.attrs.y];\n\n      [window.orbArray[x1][y1], window.orbArray[x2][y2]] =\n      [window.orbArray[x2][y2], window.orbArray[x1][y1]];\n\n      window.currentOrb.attrs.pos[0] = x2;\n      window.currentOrb.attrs.pos[1] = y2;\n\n      e.target.attrs.pos[0] = x1;\n      e.target.attrs.pos[1] = y1;\n\n      window.currentOrb.x(window.newX);\n      window.currentOrb.y(window.newY);\n\n      e.target.parent.clear();\n      window.currentOrb.parent.clear();\n\n      e.target.parent.draw();\n      window.currentOrb.draw();\n\n    }\n  }\n\n\n  findMatches () {\n    let matches = [];\n    matches = window.matchOrbs(matches);\n    while (matches.length > 0) {\n      matches = window.dropOrbs(matches);\n      // matches = window.matchOrbs(matches);\n    }\n  }\n\n  matchOrbs (matches) {\n    let orb = window.orbArray;\n    let options = {};\n    let matchId = 0;\n\n    let allMatches = {};\n\n    for (let row = 0; row < 5; row++) {\n      for (let col = 0; col < 6; col++) {\n        let color = window.orbArray[row][col].attrs.color;\n        let sek;\n        if (color === 'orb-fire') {\n          sek = \"#ff0000\";\n        } else if (color === 'orb-water') {\n          sek = \"#00ffe0\";\n        } else if (color === 'orb-wood') {\n          sek = \"#aeff00\";\n        } else if (color === 'orb-light') {\n          sek = \"#ffe400\";\n        } else if (color === 'orb-dark') {\n          sek = \"#8a00ff\";\n        } else {\n          sek = \"#ff00fc\";\n        }\n        console.log(`${row}${col}%c(■)`, `background: #222; color: ${sek}`);\n      }\n      console.log(\"___\");\n    }\n\n    for (let row = 0; row < 5; row++) {\n      for (let col = 0; col < 4; col++) {\n        options.recurs = 0;\n        options.matched = false;\n        options.matchId = matchId;\n        options = window.checkMatch(orb[row][col], orb, options, row, col);\n        // implement match order when time allows\n        for (let match in options.match) {\n          allMatches[match] = options.match[match];\n        }\n      }\n    }\n    options = {};\n\n    for (let col = 0; col < 6; col++) {\n      for (let row = 0; row < 3; row++) {\n        options.recurs = 0;\n        options.matched = false;\n        options.matchId = matchId;\n        // console.log(`checking ${row} ${col}`);\n\n        options = window.checkMatchVert(orb[row][col], orb, options, row, col);\n        for (let match in options.match) {\n          allMatches[match] = options.match[match];\n        }\n      }\n    }\n\n    for (let match in allMatches) {\n      matches.push(allMatches[match]);\n    }\n    return matches;\n  }\n\n  checkMatchVert (orb, orbs, options, x, y, match = {}) {\n    options.recurs += 1;\n\n    if (orbs[x + 1] !== undefined && orb.attrs.color === orbs[x + 1][y].attrs.color) {\n      if (options.recurs >= 2) {\n        options.matched = true;\n        orbs[x][y].attrs.matched = true;\n      }\n      options = checkMatchVert(orbs[x + 1][y], orbs, options, x + 1, y, match);\n    }\n    if (options.matched) {\n      orb.attrs.pos = [x, y];\n      match[orb.attrs.orbId] = orb;\n    }\n    // console.log(`II: orbID: ${orb.attrs.orbId} recursion: ${options.recurs}`);\n\n    if (options.match === undefined) {\n      options.match = match;\n    } else {\n      for (let orb in match) {\n        options.match[orb] = match[orb];\n      }\n    }\n    return options;\n  }\n\n  checkMatch (orb, orbs, options, x, y, match = {}) {\n    options.recurs += 1;\n\n    if (orbs[x][y + 1] !== undefined && orb.attrs.color === orbs[x][y + 1].attrs.color) {\n      if (options.recurs >= 2) {\n        options.matched = true;\n        orbs[x][y].attrs.matched = true;\n      }\n      options = checkMatch(orbs[x][y + 1], orbs, options, x, y + 1, match);\n    }\n    if (options.matched) {\n      orb.attrs.pos = [x, y];\n      match[orb.attrs.orbId] = orb;\n    }\n    if (options.match === undefined) {\n      options.match = match;\n    } else {\n      for (let orb in match) {\n        options.match[orb] = match[orb];\n      }\n    }\n    return options;\n  }\n\n  dropOrbs (matches) {\n    console.log(matches);\n    for (let i = 0; i < matches.length; i++) {\n      let pos = matches[i].attrs.pos;\n      let attrs = matches[i].attrs;\n\n      // window.orbArray[pos[0]][pos[1]].attrs.color = \"orb-matched\";\n      // window.orbArray[pos[0]][pos[1]].attrs.src = \"./img/match-pin.png\";\n\n      let orbVals = window.randomOrb();\n\n      let imgVars = { color: attrs.color, height: attrs.height,\n                      opacity: attrs.opacity, orbId: attrs.orbId,\n                      pos: attrs.pos, width: attrs.width,\n                      x: orbArray[pos[0]][pos[1]].attrs.x, y: orbArray[pos[0]][pos[1]].attrs.y\n                    };\n\n      matches[i].attrs.color = orbVals.orbType;\n      matches[i].attrs.src = orbVals.src;\n      matches[i].attrs.orbColor = orbVals.orbColor;\n\n      let img = new Image();\n\n      img.onload = window.reLoad.bind(\n        null,\n        matches[i], img,\n        window.orbs[matches[i].attrs.orbId].parent,\n        [pos[0], pos[1]],\n        imgVars\n      );\n      img.src = orbVals.src;\n\n    }\n    //window.orbs is the hash where the actual images must change\n    //window.orbArray will let us iterate through them all\n      // but orbArray's src should be changed too\n\n    return [];\n  }\n\n  reLoad (orb, img, layer, pos, atts) {\n    console.log(atts.x - 50);\n    console.log(atts.y - 50);\n    console.log(orb.attrs.orbId);\n\n    let reImage = new Kinetic.Image({\n      x: atts.x - 50, y: atts.y - 50,\n      width: 100, height: 100,\n      image: img, pos: atts.pos,\n      color: atts.color, orbId: atts.orbId,\n      draggable: false, opacity: atts.opacity\n    });\n    layer.removeChildren();\n    layer.clear();\n    window.sleep(150).then(() => {\n      layer.add(reImage);\n      layer.draw();\n      window.orbs[reImage.attrs.orbId] = reImage;\n\n      let sound = new Audio('./superlaser.mp3');\n      sound.volume = 0.3;\n      sound.currentTime = 0;\n      sound.play();\n    });\n  }\n\n  sleep (time) {\n    return new Promise((resolve) => setTimeout(resolve, time));\n  }\n}\n\n\nmodule.exports = BoardView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/pac-view.js\n ** module id = 1\n ** module chunks = 0\n **/","\nclass OrbObject {\n  constructor(params) {\n    this.pos = params.pos;\n    this.color = params.color;\n    this.img = params.img;\n    this.dragging = false;\n  }\n\n  remove() {\n    this.game.remove(this);\n  }\n}\n\nmodule.exports = OrbObject;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/orb_object.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}